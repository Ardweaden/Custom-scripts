//VERSION=3
function setup() {
  return {
    input: ['B01'],
    output: { bands: 1, sampleType: "AUTO" },
    mosaicking: "ORBIT"
  };
}

function updateOutput(outputs, collection) {
    Object.values(outputs).forEach((output) => {
        output.bands = 1 ;
    });
}
function parse_rfc3339(dt, default_h = 0, default_m = 0, default_s = 0) {
  const regexDateTime =
    "^([0-9]{4})-([0-9]{2})-([0-9]{2})([Tt]([0-9]{2}):([0-9]{2}):([0-9]{2})(\\.[0-9]+)?)?(([Zz]|([+-])([0-9]{2}):([0-9]{2})))?";
  const regexDate = "^([0-9]{4})-([0-9]{2})-([0-9]{2})$";

  let result = null;

  try {
    const g = dt.match(regexDateTime);
    if (g) {
      let date = Date.UTC(
        parseInt(g[1]), //year
        parseInt(g[2]) - 1, // month
        parseInt(g[3]), //day
        parseInt(g[5] || default_h), //hour
        parseInt(g[6] || default_m), //minute
        parseInt(g[7] || default_s), // second
        parseFloat(g[8]) * 1000 || 0 // milisecond
      );

      //for date-time strings either time zone or Z should be provided
      if (g[5] !== undefined && g[9] === undefined) {
        return null;
      }

      //check if timezone is provided
      if (g[9] !== undefined && g[9] !== "Z") {
        //offset in minutes
        const offset =
          (parseInt(g[12] || 0) * 60 + parseInt(g[13] || 0)) *
          (g[11] === "+" ? -1 : 1);
        //add offset in miliseconds
        date = date + offset * 60 * 1000;
      }

      return {
        type: dt.match(regexDate) ? "date" : "date-time",
        value: new Date(date).toISOString(),
      };
    }
  } catch (err) {
    //
  }

  return result;
}

class ProcessError extends Error {
  constructor({ name, message }) {
    super(message);
    this.name = name;
  }
}

class ValidationError extends Error {
  constructor({ name, message }) {
    super(message);
    this.name = name;
  }
}

const VALIDATION_ERRORS = {
  MISSING_PARAMETER: "MISSING_PARAMETER",
  WRONG_TYPE: "WRONG_TYPE",
  NOT_NULL: "NOT_NULL",
  NOT_ARRAY: "NOT_ARRAY",
  NOT_INTEGER: "NOT_INTEGER",
  MIN_VALUE: "MIN_VALUE",
  MAX_VALUE: "MAX_VALUE",
};

function validateParameter(arguments) {
  const {
    processName,
    parameterName,
    value,
    required = false,
    nullable = true,
    allowedTypes,
    array,
    integer,
    min,
    max,
  } = arguments;

  if (!!required && value === undefined) {
    throw new ValidationError({
      name: VALIDATION_ERRORS.MISSING_PARAMETER,
      message: `Process ${processName} requires parameter ${parameterName}.`,
    });
  }

  if (!nullable && value === null) {
    throw new ValidationError({
      name: VALIDATION_ERRORS.NOT_NULL,
      message: `Value for ${parameterName} should not be null.`,
    });
  }

  if (
    allowedTypes &&
    Array.isArray(allowedTypes) &&
    value !== null &&
    value !== undefined &&
    !allowedTypes.includes(typeof value)
  ) {
    throw new ValidationError({
      name: VALIDATION_ERRORS.WRONG_TYPE,
      message: `Value for ${parameterName} is not a ${allowedTypes.join(
        " or a "
      )}.`,
    });
  }

  if (array && !Array.isArray(value)) {
    throw new ValidationError({
      name: VALIDATION_ERRORS.NOT_ARRAY,
      message: `Value for ${parameterName} is not an array.`,
    });
  }

  if (integer && !Number.isInteger(value)) {
    throw new ValidationError({
      name: VALIDATION_ERRORS.NOT_INTEGER,
      message: `Value for ${parameterName} is not an integer.`,
    });
  }

  if (min !== undefined && min !== null && value < min) {
    throw new ValidationError({
      name: VALIDATION_ERRORS.MIN_VALUE,
      message: `Value for ${parameterName} must be greater or equal to ${min}.`,
    });
  }

  if (max !== undefined && max !== null && value > max) {
    throw new ValidationError({
      name: VALIDATION_ERRORS.MAX_VALUE,
      message: `Value for ${parameterName} must be less or equal to ${max}.`,
    });
  }

  return true;
}

class DataCube {
    constructor(data, bands_dimension_name, temporal_dimension_name, fromSamples) {
        this.TEMPORAL = "temporal"
        this.BANDS = "bands"
        this.OTHER = "other"
        this.bands_dimension_name = bands_dimension_name;
        this.temporal_dimension_name = temporal_dimension_name;
        this.dimensions = [{
            name: this.temporal_dimension_name,
            labels: [],
            type: this.TEMPORAL
        }, {
            name: this.bands_dimension_name,
            labels: [],
            type: this.BANDS
        }]
        if (fromSamples) {
            this.data = this.makeArrayFromSamples(data)
        } else {
            this.data = data;
        }
    }

    getDimensionByName(name) {
        return this.dimensions.find(d => d.name === name)
    }

    makeArrayFromSamples(samples) {
        if (Array.isArray(samples)) {
            let newData = []
            for (let entry of samples) {
                if (this.getDimensionByName(this.bands_dimension_name).labels.length === 0) {
                    this.getDimensionByName(this.bands_dimension_name).labels = Object.keys(entry)
                }
                newData.push(Object.values(entry))
            }
            return newData
        } else {
            if (this.getDimensionByName(this.bands_dimension_name).labels.length === 0) {
                this.getDimensionByName(this.bands_dimension_name).labels = Object.keys(samples)
            }
            return Object.values(samples)
        }
    }

    getBandIndices(bands) {
        return bands.map(b => this.getDimensionByName(this.bands_dimension_name).labels.indexOf(b))
    }

    filterBands(bands) {
        const indices = this.getBandIndices(bands);
        const axis = this.dimensions.findIndex((e) => e.name === this.bands_dimension_name);
        this.data = this._filter(this.data, axis, indices);
        this.getDimensionByName(this.bands_dimension_name).labels =
          this.getDimensionByName(this.bands_dimension_name).labels.filter((lab) =>
            bands.includes(lab)
          );
      }

    removeDimension(dimension) {
        this.dimensions = this.dimensions.filter(d => d.name !== dimension)
    }

    addDimension(name, label, type) {
        this.data = this._addDimension(this.data, 0)
        this.dimensions.unshift({
            name: name,
            labels: [label],
            type: type
        })
    }

    clone() {
        const copy = new DataCube(this._iter(this.data), this.bands_dimension_name, this.temporal_dimension_name)
        copy.dimensions = JSON.parse(JSON.stringify(this.dimensions))
        return copy
    }

    flattenToArray() {
        const flattenedData = this.flatten();
        return Array.isArray(flattenedData) ? flattenedData : [flattenedData]
    }

    encodeData() {
        const shape = this.getDataShape();
        const flattenedData = this.flattenToArray();
        return [...shape, ...flattenedData];
    }


    _iter(arr, execute = v => v, removeDim = () => false, execute_on_result = r => r, coords = []) {
        if (Array.isArray(arr)) {
            let result = []
            for (let i = 0; i < arr.length; i++) {
                const val = this._iter(arr[i], execute, removeDim, execute_on_result, [...coords, i])
                if (val !== undefined) {
                    result.push(val)
                }
            }
            result = execute_on_result(result, coords)
            if (result.length === 0) {
                return
            }
            const shouldRemoveDim = removeDim(coords)
            if (shouldRemoveDim && result.length !== 1) {
                throw new Error('Can only remove dimension of length 1!')
            } else if (shouldRemoveDim) {
                return result[0]
            }
            return result
        } else {
            return execute(arr, coords)
        }
    }

    reduceByDimension(reducer, dimension) {
        let newData = this._iter(this.data)
        const axis = this.dimensions.findIndex(e => e.name === dimension)
        const shape = this.getDataShape()
        const coords = new Array(shape.length).fill(0);
        coords[axis] = null;
        let currInd = 0;
        const labels = this.dimensions[axis].labels

        while (true) {
            if (coords[currInd] === null) {
                currInd++
            }
            if (currInd >= shape.length) {
                break;
            }
            const dataToReduce = this._select(newData, coords)
            dataToReduce.labels = labels
            const newVals = reducer({
                data: dataToReduce
            })
            newData = this._set(newData, newVals, coords)
            if (coords[currInd] + 1 >= shape[currInd]) {
                currInd++
            } else {
                coords[currInd]++
            }
        }
        const finalSelectCoords = new Array(shape.length).fill(null);
        finalSelectCoords[axis] = 0;
        this.data = this._select(newData, finalSelectCoords);
        this.removeDimension(dimension)
    }

    flatten() {
        const flattenArr = (arr) => arr.reduce((flat, next) => flat.concat(next), []);
        return this._iter(this.data, v => v, () => false, r => {
            return flattenArr(r)
        })
    }

    getDataShape() {
        let dimensions;
        this._iter(this.data, (a, coords) => {
            dimensions = coords;
            return a
        })
        return dimensions.map(d => d + 1)
    }

    _addDimension(arr, axis) {
        // new dimension is added before the axis
        if (!Array.isArray(arr)) {
            return [arr]
        }
        return this._iter(arr, v => v, () => false, (r, c) => {
            if (c.length === axis) {
                return [r]
            }
            return r
        })
    }

    _select(arr, coordArr) {
        // coordArr: 1D list of n coordinates. If m-th place has `null`, the entire axis is included and the dimension is kept
        function coordInSlice(c1, sliceArr) {
            return sliceArr.every((e, i) => e === null || e === c1[i])
        }
        return this._iter(arr, (a, coords) => {
            if (coordInSlice(coords, coordArr)) {
                return a
            }
        }, coords => coords.length >= coordArr.length || coordArr[coords.length] === null ? false : true)
    }

    _set(arr, vals, coordArr) {
        // Set values at coordArr
        function coordInSlice(c1, sliceArr) {
            return c1.length === sliceArr.length && sliceArr.every((e, i) => e === null || e === c1[i])
        }
        const exec_set = (a, coords) => {
            if (coordInSlice(coords, coordArr)) {
                let valueToSet;
                if (Array.isArray(vals)) {
                    valueToSet = this._select(vals, coordArr.map((c, i) => c === null ? coords[i] : null).filter(c => c !== null))
                } else {
                    valueToSet = vals
                }
                return valueToSet
            }
            return a
        }
        return this._iter(arr, exec_set)
    }

    _filter(arr, dim, coordArr) {
        const exec_filter = (a, coords) => {
            if (coordArr.includes(coords[dim])) {
                return a
            }
        }
        return this._iter(arr, exec_filter)
    }

    apply(process) {
      const newData = this._iter(this.data, x=>process({"x": x}));
      this.data = newData;
    }
}

        function reduce_dimension_1409df2ec6ae4dfc82d2074d8dea15a3(arguments) {

        function reduce_dimension(arguments) {
            function reducer(arguments) {

                        function mean_eed449bdc8f04111baacae4d9acc97f1(arguments) {
                                        function mean(arguments) {
                                          const { data, ignore_nodata = true } = arguments;

                                          if (data === undefined) {
                                            throw new Error("Mandatory argument `data` is not defined.");
                                          }

                                          if (!Array.isArray(data)) {
                                            throw new Error("Argument `data` is not an array.");
                                          }

                                          if (typeof ignore_nodata !== "boolean") {
                                            throw new Error("Argument `ignore_nodata` is not a boolean.");
                                          }

                                          let sum = 0;
                                          let el_num = 0;

                                          for (let x of data) {
                                            if (typeof x !== "number" && x !== null) {
                                              throw new Error("Element in argument `data` is not a number or null.");
                                            }

                                            if (x === null) {
                                              if (ignore_nodata) {
                                                continue;
                                              } else {
                                                return null;
                                              }
                                            }

                                            sum += x;
                                            el_num++;
                                          }

                                          if (el_num === 0) {
                                            return null;
                                          }

                                          return sum / el_num;
                                        }

                            return mean(arguments)
                        }

                        let node_1 = mean_eed449bdc8f04111baacae4d9acc97f1({"data": arguments.data})
                return node_1;
            }

            const {data, dimension} = arguments;
            const newData = data.clone()
            newData.reduceByDimension(reducer, dimension)
            return newData;
        }

            return reduce_dimension(arguments)
        }

function evaluatePixel(samples) {
    let node_1 = new DataCube(samples, 'bands', 't', true)
        let node_2 = reduce_dimension_1409df2ec6ae4dfc82d2074d8dea15a3({"data": node_1, "dimension": "t", "reducer": {"process_graph": {"1": {"process_id": "mean", "arguments": {"data": {"from_parameter": "data"}}, "result": true}}}})
    return node_2.flattenToArray()
}
